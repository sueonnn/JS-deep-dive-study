# 11장- 원시 값과 객체의 비교

자바스크립트는 7가지 데이터 타입(숫자, 문자, 불리언, null, undefined, 심벌, 객체 타입)이 있다.

이 데이터 타입은 **원시타입**(primitive type)과 **객체타입**(object type)으로 구분한다.

값 할당 시

| 원시 타입 | 객체 타입 |
| --- | --- |
| 변경 불가능한 값 | 변경 가능한 값 |
| 메모리에 값 저장 | 메모리에 참조 값 저장 |

할당 된 변수를 다른 값에 할딩 시

| 원시 타입  | 객체 타입 |
| --- | --- |
| 원본 값 복사되어 전달(값에 의한 전달) | 참조값 복사되어 전달(참조에 의한 전달) |

**변수** - 하나의 값을 저장하기 위해 확보한 메모리 공간 자체, 또는 그 메모리 공간을 식별하기 위해 붙인 이름

**값** - 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과.

## 원시 값

변경 불가능한 값

변수는 재할당을 통해 값을 변경할 수 있지만 값은 변경이 불가능하다. (상수는 재할당 불가)

![Untitled](11%E1%84%8C%E1%85%A1%E1%86%BC-%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%20%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%206b266f8c72f3416b86f093f048a8b847/Untitled.png)

<aside>
💡 원시값이 변경 가능하다면 아래와 같이 동작한다.

![Untitled](11%E1%84%8C%E1%85%A1%E1%86%BC-%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%20%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%206b266f8c72f3416b86f093f048a8b847/Untitled%201.png)

</aside>

불변성 : 원시값의 특성, 값을 할당할 때마다 새 메모리 공간에 저장된다.

불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.

### 값에 의한 전달

원시 값이 할당된 변수를 다른 변수에 할당하면 원시 값이 복사 되어 전달되는데 이를

 **값에 의한 전달**이라 한다.

<aside>
💡 정확히 말하면 값을 전달하는 것이 아닌 값이 저장된 **메모리 주소를 전달**한다. 
전달된 메모리 주소를 통해 값을 참조한다.

</aside>

```jsx
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy); // 80

score = 100;

console.log(score); // ?
console.log(copy); // ?
```

- 정답
    
    100, 80
    
    <aside>
    💡 위의 예시는 score값과 copy값이 다른 메모리 공간에 저장된 별개의 값이기 때문에 score변수의 값을 변경해도 copy변수 값에는 어떤 영향도 주지 않는다.
    
    </aside>
    

## 객체

객체는 프로퍼티 개수가 정해져 있지 않고, 동적으로 추가되고 삭제할 수 있다.

따라서 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.

### 변경 가능한 값

객체(참조) 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다.

객체를 할당하면 변수에 객체가 저장된 메모리 공간의 주소가 저장된다.

```jsx
// 할당이 이뤄지는 시점에 객체 리터럴이 해석되고, 그 결과 객체가 생성된다
var person = {
  name: "Lee"
}

// person 변수에 저장되어 있는 참조 값으로 실제 객체에 접근한다
console.log(person); // {name: "Lee"
```

![Untitled](11%E1%84%8C%E1%85%A1%E1%86%BC-%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%20%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%206b266f8c72f3416b86f093f048a8b847/Untitled%202.png)

객체는 변경 가능한 값이므로 재할당 없이 수정(프로퍼티를 동적으로 추가, 갱신, 삭제)할 수 있다.

재할당이 이루어지지 않았으므로 객체를 할당한 변수의 참조 값은 변경되지 않는다.

```jsx
// 프로퍼티 값 갱신
person.name = "Kim";

// 프로퍼티 값 동적 생성
person.address = "Seoul";

console.log(person); // {name: "Park", address: "Seoul"}
```

![Untitled](11%E1%84%8C%E1%85%A1%E1%86%BC-%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%20%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%206b266f8c72f3416b86f093f048a8b847/Untitled%203.png)

객체는 경우에 따라 원시값보다 크기가 매우 클 수 있다.

따라서 객체는 **메모리를 효율적으로 사용**하기 위해, **객체를 복사해 생성하는 비용을 절약**(메모리 공간 절약)하여 성능을 향상시키기 위해 **변경 가능한 값**으로 설계되었다.

이러한 구조적 특징으로 아래와 같이 **여러 개의 식별자가 하나의 객체를 공유**할 수 있는 문제가 있다.

```jsx
const obj1 = {name: 'boeun', address: "Seoul"};
const obj2 = obj1;

console.log(obj1 === obj2); // true;
```

![Untitled](11%E1%84%8C%E1%85%A1%E1%86%BC-%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%20%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%206b266f8c72f3416b86f093f048a8b847/Untitled%204.png)

### 참조에 의한 전달

여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이 무엇을 의미하는지, 이로 인해 어떤 부작용이 발생 하는지 알아보자

```jsx
var person = {
  name : 'Lee'
};

// 참조 값을 복사(얕은 복사)
var copy = person;
```

![Untitled](11%E1%84%8C%E1%85%A1%E1%86%BC-%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%20%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%206b266f8c72f3416b86f093f048a8b847/Untitled%205.png)

위의 person과 copy는 메모리 주소는 다르지만 동일한 참조값을 갖는다.

다시 말해, person과 copy는 동일한 객체를 가리킨다. 이것은 **두 개의 식별자가 하나의 객체를 공유**한다는 것을 의미한다.

```jsx
var person = {
  name : 'Lee'
};

// 참조 값 복사
var copy = person;

// 동일한 객체 공유
console.log(copy === person); // true;

copy.name = 'Kim';

person.address = 'Seoul';

// 어느 한 쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
console.log(person); // {name: 'Kim', address: 'Seoul'}
console.log(copy); // {name: 'Kim', address: 'Seoul'}
```

---

<aside>
💡 “값에 의한 전달”과 “참조에 의한 전달”은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다.
자바스크립트에서는 “참조에 의한 전달”은 존재하지 않고 “값에 의한 전달”만이 존재한다고 말할 수 있다.

</aside>

### 얕은 복사

객체를 프로퍼티 값으로 갖는 객체의 경우 한 단계까지만 복사하는 것을 말한다.

중첩된 객체의 경우 참조 값을 복사한다.

```jsx
const o = {x : {y : 1}};
// 얕은 복사
const c1 = {...o}; // 35장 스프레드 문법 참고
console.log(c1 === o); // false
console.log(c1.x === o.x); // true
```

![Untitled](11%E1%84%8C%E1%85%A1%E1%86%BC-%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%20%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8B%E1%85%B4%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%206b266f8c72f3416b86f093f048a8b847/Untitled%206.png)

### 깊은 복사

객체에 중첩되어 있는 객체까지 모두 복사해 원시 값처럼 완전한 복사본을 만든다.

```jsx
const _ = require("ladash");

// 깊은 복사
const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false
```

얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체다. 즉 원본과 복사본은 참조 값이 다른 별개의 객체다.

```jsx
const v = 1;

// 원시 값을 할당한 변수를 다른 변수에 할당하는 것을 깊은 복사 라고 부르기도 한다.
// 값 자체를 복사
const c1 = v;
console.log(c1 === v); // true

const o = {x: 1};

// 객체를 할당한 변수를 다른 변수에 할당하는 것을 얕은 복사 라고 부르기도 한다.
// 참조값을 복사
const c2 = o;
console.log(c2 === o); // true
```